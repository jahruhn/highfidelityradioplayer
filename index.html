<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>High Fidelity Radio Player</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style id="theme-style">
    :root {
      --bg: #181f2a;
      --fg: #f4f6fa;
      --panel: #212c3b;
      --accent: #24b47e;
      --accent-hover: #007557;
      --header: #28364a;
      --tip-bg: #17212f;
      --border: #2d3d53;
      --mute: #94a3b8;
      --status: #fcb900;
      --processing: #94d82d;
    }
    body {
      background: var(--bg);
      color: var(--fg);
      font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 0; min-height: 100vh;
      transition: background 0.3s, color 0.3s;
    }
    header {
      background: var(--header); padding: 1.5em 0 1em 0; text-align: center;
    }
    header h1 { margin: 0; font-size: 2em; letter-spacing: 0.05em; }
    #theme-toggle {
      position: absolute; right: 1.5em; top: 1.5em; font-size: 1.2em; cursor: pointer;
      background: none; border: none; color: var(--fg);
    }
    #app-container {
      max-width: 500px; margin: 2.5em auto; background: var(--panel);
      border-radius: 10px; box-shadow: 0 2px 20px rgba(0,0,0,0.2);
      padding: 2em 2em 1em 2em;
    }
    label, input, button, select { display: block; width: 100%; }
    label { margin-bottom: 0.7em; }
    input[type="text"] {
      padding: 0.7em; border: none; border-radius: 5px; font-size: 1em; margin-bottom: 1em;
      background: var(--border); color: var(--fg);
    }
    button, select {
      background: var(--accent); color: #fff; border: none; padding: 0.9em 0;
      border-radius: 5px; font-size: 1.1em; margin-bottom: 1em; cursor: pointer;
      transition: background 0.2s;
    }
    button:hover, select:hover { background: var(--accent-hover); }
    .status { margin: 1em 0 0.5em 0; color: var(--status); font-size: 1em; min-height: 1.5em; }
    .processing { margin-bottom: 1em; color: var(--processing); font-size: 0.95em; min-height: 1.2em; }
    .tips {
      margin-top: 2em; color: var(--mute); font-size: 0.95em;
      background: var(--tip-bg); padding: 1em; border-radius: 7px;
    }
    .switch-row {
      display: flex; gap: 1em; flex-wrap: wrap; margin-bottom: 1em;
    }
    .switch-row > * { flex: 1 1 48%; }
    #audio-controls { text-align: center; margin-top: 1em; margin-bottom: 1em; }
    #audio-controls button {
      width: 46%; display: inline-block; margin: 0 2% 1em 0;
    }
    @media (max-width:600px) {
      #app-container { padding: 1em 0.5em 1em 0.5em; }
      .switch-row { flex-direction: column; gap: 0; }
      .switch-row > * { width: 100%; }
    }

    /* Light mode */
    .light {
      --bg: #f5f7fa;
      --fg: #23262d;
      --panel: #fff;
      --accent: #24b47e;
      --accent-hover: #1d7a56;
      --header: #d8e3ed;
      --tip-bg: #f0f4f8;
      --border: #ececec;
      --mute: #6b7a90;
      --status: #fbb900;
      --processing: #6eb800;
    }
  </style>
</head>
<body>
  <header>
    <button id="theme-toggle" title="Toggle dark/light mode">🌙</button>
    <h1>High Fidelity Radio Player</h1>
    <div style="font-size:1.1em;color:var(--status);">Enter a compatible internet radio stream URL</div>
  </header>
  <div id="app-container">
    <label for="streamUrl"><b>Stream URL:</b></label>
    <input id="streamUrl" type="text" placeholder="e.g. https://radio.example.com/stream" autocomplete="off">
    <div class="switch-row">
      <select id="presetSelect">
        <option value="natural">🎧 Natural (default)</option>
        <option value="creative">🎨 Creative</option>
      </select>
      <select id="orderSelect">
        <option value="expander-exciter">Expander → Exciter</option>
        <option value="exciter-expander">Exciter → Expander</option>
      </select>
    </div>
    <div id="audio-controls">
      <button id="playBtn">Play Stream</button>
      <button id="pauseBtn">Pause</button>
      <button id="stopBtn">Stop</button>
      <button id="muteBtn">Mute</button>
      <div style="margin-top:0.5em;">
        <input id="progressBar" type="range" min="0" max="100" value="0" step="0.1" style="width:100%;">
        <span id="currentTime">00:00</span> / <span id="duration">--:--</span>
      </div>
      <canvas id="levelMeter" width="220" height="16" style="margin-top:0.7em;display:block;margin-left:auto;margin-right:auto;background:#222;border-radius:4px;"></canvas>
    </div>
    <div class="status" id="songinfo">No stream loaded.</div>
    <div class="processing" id="processingStatus">
      Audio FX Chain: <span id="fxChainLabel">Expander → Exciter</span>
    </div>
    <!-- Hidden audio element -->
    <audio id="audio" crossorigin="anonymous"></audio>
    <div class="tips">
      <b>Tips:</b>
      <ul>
        <li>Works best with streams that support CORS and standard codecs (MP3/AAC).</li>
        <li>If song info isn’t shown, the stream may not send track metadata or allow access from browsers.</li>
        <li>All audio is enhanced in real time with FX: Expander, Exciter</li>
        <li>Switch between <b>Natural</b> and <b>Creative</b> presets for different sound characters.</li>
        <li>Change the FX order for alternate sound textures.</li>
      </ul>
    </div>
  </div>
<script>
const audio = document.getElementById('audio');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const muteBtn = document.getElementById('muteBtn');
const urlInput = document.getElementById('streamUrl');
const songinfo = document.getElementById('songinfo');
const processingStatus = document.getElementById('processingStatus');
const themeToggle = document.getElementById('theme-toggle');
const presetSelect = document.getElementById('presetSelect');
const orderSelect = document.getElementById('orderSelect');
const fxChainLabel = document.getElementById('fxChainLabel');
const progressBar = document.getElementById('progressBar');
const currentTimeLabel = document.getElementById('currentTime');
const durationLabel = document.getElementById('duration');
const levelMeter = document.getElementById('levelMeter');

let ctx, src, expander, exciter, gainNode, analyser;

let meterAnimId = null;

// Draw level meter (simple peak)
function drawLevelMeter(level) {
  const ctx2d = levelMeter.getContext('2d');
  ctx2d.clearRect(0, 0, levelMeter.width, levelMeter.height);
  // Background bar
  ctx2d.fillStyle = '#333';
  ctx2d.fillRect(0, 0, levelMeter.width, levelMeter.height);
  // Level bar
  const w = Math.max(2, level * levelMeter.width);
  ctx2d.fillStyle = level > 0.85 ? '#f55' : (level > 0.6 ? '#fc0' : '#3fa');
  ctx2d.fillRect(0, 0, w, levelMeter.height);
}

// Start meter animation
function startLevelMeter() {
  if (!analyser) {
    analyser = ctx.createAnalyser();
    analyser.fftSize = 256;
  }
  // Connect analyser after FX chain and gain
  if (orderSelect.value === 'expander-exciter') {
    exciter.connect(analyser);
  } else {
    expander.connect(analyser);
  }
  analyser.connect(gainNode);
  gainNode.connect(ctx.destination);

  function animate() {
    const data = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(data);
    // Calculate peak level (normalized 0..1)
    let peak = 0;
    for (let i = 0; i < data.length; i++) {
      const v = (data[i] - 128) / 128;
      peak = Math.max(peak, Math.abs(v));
    }
    drawLevelMeter(peak);
    meterAnimId = requestAnimationFrame(animate);
  }
  animate();
}

// Stop meter animation
function stopLevelMeter() {
  if (meterAnimId) cancelAnimationFrame(meterAnimId);
  drawLevelMeter(0);
}

function setTheme(mode) {
  document.body.classList.toggle('light', mode === 'light');
  themeToggle.textContent = mode === 'light' ? '🌙' : '☀️';
}
themeToggle.onclick = function() {
  const isLight = document.body.classList.toggle('light');
  themeToggle.textContent = isLight ? '🌙' : '☀️';
  localStorage.setItem('theme', isLight ? 'light' : 'dark');
};
// Restore theme on load
(function() {
  const saved = localStorage.getItem('theme');
  if (saved === 'light') setTheme('light');
})();

function getPresetParams() {
  switch (presetSelect.value) {
    case 'creative':
      return {
        exp: { threshold: -60, knee: 25, ratio: 1.2, attack: 0.002, release: 0.1 },
        exc: { curve: 24 }
      };
    default: // natural
      return {
        exp: { threshold: -45, knee: 40, ratio: 1.5, attack: 0.005, release: 0.3 },
        exc: { curve: 10 }
      };
  }
}

function updateFxChainLabel() {
  fxChainLabel.textContent = orderSelect.value === 'expander-exciter'
    ? "Expander → Exciter"
    : "Exciter → Expander";
}
orderSelect.onchange = updateFxChainLabel;
presetSelect.onchange = updateFxChainLabel;

playBtn.onclick = () => {
  const url = urlInput.value.trim();
  if (!url) {
    songinfo.textContent = 'Please enter a stream URL.';
    return;
  }
  audio.src = url;
  audio.play().catch(e => {
    songinfo.textContent = 'Unable to play stream. Check the URL and CORS support.';
  });

  if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
  if (src) src.disconnect();
  if (analyser) analyser.disconnect();

  src = ctx.createMediaElementSource(audio);
  const p = getPresetParams();

  // ==== Expander ====
  expander = ctx.createDynamicsCompressor();
  expander.threshold.value = p.exp.threshold;
  expander.knee.value = p.exp.knee;
  expander.ratio.value = p.exp.ratio;
  expander.attack.value = p.exp.attack;
  expander.release.value = p.exp.release;

  // ==== Exciter ====
  exciter = ctx.createWaveShaper();
  function makeExciterCurve(amount = 10) {
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    for (let i = 0; i < n_samples; ++i) {
      let x = i * 2 / n_samples - 1;
      curve[i] = Math.tanh(amount * x);
    }
    return curve;
  }
  exciter.curve = makeExciterCurve(p.exc.curve);
  exciter.oversample = '4x';

  // ==== Gain node for loudness normalization ====
  if (gainNode) gainNode.disconnect();
  gainNode = ctx.createGain();
  // Set gain for approx -14 dB RMS (0 dBFS = gain 1.0, -14 dB ≈ 0.2)
  gainNode.gain.value = 0.2;

  // ---- Chain order switch ----
  let nodeA, nodeB;
  if (orderSelect.value === 'expander-exciter') {
    nodeA = expander; nodeB = exciter;
    processingStatus.style.color = "var(--processing)";
  } else {
    nodeA = exciter; nodeB = expander;
    processingStatus.style.color = "#66aaff";
  }
  src.connect(nodeA);
  nodeA.connect(nodeB);
  nodeB.connect(gainNode);
  // analyser will be connected in startLevelMeter
  // gainNode.connect(ctx.destination);

  // ==== Song Info (best effort) ====
  fetchSongInfo(url);

  startLevelMeter();
};

stopBtn.onclick = () => {
  audio.pause();
  audio.src = '';
  songinfo.textContent = 'No stream loaded.';
  if (src) src.disconnect();
  if (analyser) analyser.disconnect();
  stopLevelMeter();
};

// Pause functionality
pauseBtn.onclick = () => {
  audio.pause();
};

// Mute/unmute
muteBtn.onclick = () => {
  audio.muted = !audio.muted;
  muteBtn.textContent = audio.muted ? "Unmute" : "Mute";
};

// Progress bar update
audio.addEventListener('timeupdate', () => {
  if (audio.duration && isFinite(audio.duration)) {
    progressBar.max = audio.duration;
    progressBar.value = audio.currentTime;
    durationLabel.textContent = formatTime(audio.duration);
  } else {
    progressBar.value = 0;
    durationLabel.textContent = "--:--";
  }
  currentTimeLabel.textContent = formatTime(audio.currentTime);
});

// Seek (if supported)
progressBar.oninput = () => {
  if (audio.duration && isFinite(audio.duration)) {
    audio.currentTime = progressBar.value;
  }
};

// Format time helper
function formatTime(sec) {
  if (!isFinite(sec)) return "00:00";
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// Reset controls on stop
stopBtn.onclick = () => {
  audio.pause();
  audio.src = '';
  songinfo.textContent = 'No stream loaded.';
  if (src) src.disconnect();
};

// ---- Song Info Fetching ----
// (remains the same)
function fetchSongInfo(url) {
  songinfo.textContent = "Connecting to: " + url;
  fetch(url, {
    method: 'GET',
    headers: { 'Icy-MetaData': '1' },
    mode: 'cors'
  })
  .then(resp => {
    if (!resp.ok) throw new Error('No ICY metadata available.');
    songinfo.textContent = "Connected: " + url;
  })
  .catch(() => {
    songinfo.textContent = "Playing: " + url + " (No song info available)";
  });
}

// Initial UI state
updateFxChainLabel();
</script>
</body>
</html>
